{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getBreaksNeededForEmptyLineAfter = exports.getBreaksNeededForEmptyLineBefore = exports.selectWord = exports.getSurroundingWord = void 0;\n\nfunction getSurroundingWord(text, position) {\n  if (!text) throw Error(\"Argument 'text' should be truthy\");\n\n  var isWordDelimiter = function (c) {\n    return c === \" \" || c.charCodeAt(0) === 10;\n  }; // leftIndex is initialized to 0 because if selection is 0, it won't even enter the iteration\n\n\n  var start = 0; // rightIndex is initialized to text.length because if selection is equal to text.length it won't even enter the interation\n\n  var end = text.length; // iterate to the left\n\n  for (var i = position; i - 1 > -1; i--) {\n    if (isWordDelimiter(text[i - 1])) {\n      start = i;\n      break;\n    }\n  } // iterate to the right\n\n\n  for (var i = position; i < text.length; i++) {\n    if (isWordDelimiter(text[i])) {\n      end = i;\n      break;\n    }\n  }\n\n  return {\n    start: start,\n    end: end\n  };\n}\n\nexports.getSurroundingWord = getSurroundingWord;\n/**\n * If the cursor is inside a word and (selection.start === selection.end)\n * returns a new Selection where the whole word is selected\n * @param text\n * @param selection\n */\n\nfunction selectWord(_a) {\n  var text = _a.text,\n      selection = _a.selection;\n\n  if (text && text.length && selection.start === selection.end) {\n    // the user is pointing to a word\n    return getSurroundingWord(text, selection.start);\n  }\n\n  return selection;\n}\n\nexports.selectWord = selectWord;\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\n\nfunction getBreaksNeededForEmptyLineBefore(text, startPosition) {\n  if (text === void 0) {\n    text = \"\";\n  }\n\n  if (startPosition === 0) return 0; // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInFirstLine = true;\n\n  for (var i = startPosition - 1; i >= 0 && neededBreaks >= 0; i--) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        // blank space\n        continue;\n\n      case 10:\n        // line break\n        neededBreaks--;\n        isInFirstLine = false;\n        break;\n\n      default:\n        return neededBreaks;\n    }\n  }\n\n  return isInFirstLine ? 0 : neededBreaks;\n}\n\nexports.getBreaksNeededForEmptyLineBefore = getBreaksNeededForEmptyLineBefore;\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\n\nfunction getBreaksNeededForEmptyLineAfter(text, startPosition) {\n  if (text === void 0) {\n    text = \"\";\n  }\n\n  if (startPosition === text.length - 1) return 0; // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  var neededBreaks = 2;\n  var isInLastLine = true;\n\n  for (var i = startPosition; i < text.length && neededBreaks >= 0; i++) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        continue;\n\n      case 10:\n        {\n          neededBreaks--;\n          isInLastLine = false;\n          break;\n        }\n\n      default:\n        return neededBreaks;\n    }\n  }\n\n  return isInLastLine ? 0 : neededBreaks;\n}\n\nexports.getBreaksNeededForEmptyLineAfter = getBreaksNeededForEmptyLineAfter;","map":{"version":3,"names":["Object","defineProperty","exports","value","getBreaksNeededForEmptyLineAfter","getBreaksNeededForEmptyLineBefore","selectWord","getSurroundingWord","text","position","Error","isWordDelimiter","c","charCodeAt","start","end","length","i","_a","selection","startPosition","neededBreaks","isInFirstLine","isInLastLine"],"sources":["C:/Users/thewi/Downloads/scrimba/notes/node_modules/react-mde/lib/js/util/MarkdownUtil.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getBreaksNeededForEmptyLineAfter = exports.getBreaksNeededForEmptyLineBefore = exports.selectWord = exports.getSurroundingWord = void 0;\nfunction getSurroundingWord(text, position) {\n    if (!text)\n        throw Error(\"Argument 'text' should be truthy\");\n    var isWordDelimiter = function (c) { return c === \" \" || c.charCodeAt(0) === 10; };\n    // leftIndex is initialized to 0 because if selection is 0, it won't even enter the iteration\n    var start = 0;\n    // rightIndex is initialized to text.length because if selection is equal to text.length it won't even enter the interation\n    var end = text.length;\n    // iterate to the left\n    for (var i = position; i - 1 > -1; i--) {\n        if (isWordDelimiter(text[i - 1])) {\n            start = i;\n            break;\n        }\n    }\n    // iterate to the right\n    for (var i = position; i < text.length; i++) {\n        if (isWordDelimiter(text[i])) {\n            end = i;\n            break;\n        }\n    }\n    return { start: start, end: end };\n}\nexports.getSurroundingWord = getSurroundingWord;\n/**\n * If the cursor is inside a word and (selection.start === selection.end)\n * returns a new Selection where the whole word is selected\n * @param text\n * @param selection\n */\nfunction selectWord(_a) {\n    var text = _a.text, selection = _a.selection;\n    if (text && text.length && selection.start === selection.end) {\n        // the user is pointing to a word\n        return getSurroundingWord(text, selection.start);\n    }\n    return selection;\n}\nexports.selectWord = selectWord;\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\nfunction getBreaksNeededForEmptyLineBefore(text, startPosition) {\n    if (text === void 0) { text = \"\"; }\n    if (startPosition === 0)\n        return 0;\n    // rules:\n    // - If we're in the first line, no breaks are needed\n    // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n    //      may need to insert 0, 1 or 2 breaks\n    var neededBreaks = 2;\n    var isInFirstLine = true;\n    for (var i = startPosition - 1; i >= 0 && neededBreaks >= 0; i--) {\n        switch (text.charCodeAt(i)) {\n            case 32: // blank space\n                continue;\n            case 10: // line break\n                neededBreaks--;\n                isInFirstLine = false;\n                break;\n            default:\n                return neededBreaks;\n        }\n    }\n    return isInFirstLine ? 0 : neededBreaks;\n}\nexports.getBreaksNeededForEmptyLineBefore = getBreaksNeededForEmptyLineBefore;\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\nfunction getBreaksNeededForEmptyLineAfter(text, startPosition) {\n    if (text === void 0) { text = \"\"; }\n    if (startPosition === text.length - 1)\n        return 0;\n    // rules:\n    // - If we're in the first line, no breaks are needed\n    // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n    //      may need to insert 0, 1 or 2 breaks\n    var neededBreaks = 2;\n    var isInLastLine = true;\n    for (var i = startPosition; i < text.length && neededBreaks >= 0; i++) {\n        switch (text.charCodeAt(i)) {\n            case 32:\n                continue;\n            case 10: {\n                neededBreaks--;\n                isInLastLine = false;\n                break;\n            }\n            default:\n                return neededBreaks;\n        }\n    }\n    return isInLastLine ? 0 : neededBreaks;\n}\nexports.getBreaksNeededForEmptyLineAfter = getBreaksNeededForEmptyLineAfter;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}